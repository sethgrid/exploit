package main

import (
	"flag"
	"fmt"
	"log"
	"math/rand"
	"net/http"
	"sync"
	"time"
)

const letterBytes = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

var hostname string
var port int
var activeKeys sync.Map

func main() {
	flag.StringVar(&hostname, "hostname", "localhost", "set to the host from which you run the script")
	flag.IntVar(&port, "port", 5050, "port to run server upon")
	flag.Parse()

	mux := http.NewServeMux()
	mux.HandleFunc("/download", downloadHandler)
	mux.HandleFunc("/check", checkHandler)

	log.Printf("starting on :%d", port)
	log.Printf("try `curl %s:%d/download`", hostname, port)
	if err := http.ListenAndServe(fmt.Sprintf("127.0.0.1:%d", port), mux); err != nil {
		log.Fatal(err)
	}
}

func downloadHandler(w http.ResponseWriter, r *http.Request) {
	log.Println("/download")
	key := genRandKey(5)
	activeKeys.Store(key, false)
	defer activeKeys.Delete(key)

	// w.Header().Set("X-Content-Type-Options", "nosniff")
	w.Header().Set("Transfer-Encoding", "chunked")
	// w.Header().Set("Connection", "Keep-Alive")

	fmt.Fprintf(w, filePart1(key))
	flush(w)
	time.Sleep(100 * time.Millisecond)
	if ok := pollKeys(key, 2*time.Second); ok {
		fmt.Fprintf(w, filePart2UnSafe())
	} else {
		fmt.Fprintf(w, filePart2Safe())
	}
	flush(w)
}

func checkHandler(w http.ResponseWriter, r *http.Request) {
	key := r.URL.Query().Get("key")
	log.Printf("/check?key %q", key)
	count := 0
	activeKeys.Range(func(k, v interface{}) bool {
		count++
		log.Printf("found key: %v - %v", k, v)
		return true
	})
	if count == 0 {
		log.Println("no keys found")
	}
	if _, ok := activeKeys.Load(key); ok {
		log.Println("key found in store, setting active to true")
		activeKeys.Store(key, true)
	}
}

func pollKeys(key string, timeout time.Duration) bool {
	tick := time.NewTicker(250 * time.Millisecond)
	dieTime := time.Now().Add(timeout)
	defer tick.Stop()

	for range tick.C {
		log.Println("polling...")
		// check if the key is present
		if isActive, ok := activeKeys.Load(key); ok {
			// check that the key is true as false means they did not auto-curl via pipe to bash
			log.Println("key is present. Checking if key has activated itself...")
			if v, ok := isActive.(bool); ok && v {
				log.Println("key is active")
				return true
			}
		}
		if dieTime.Before(time.Now()) {
			log.Println("polling expired")
			return false
		}
	}
	return false
}

func genRandKey(n int) string {
	b := make([]byte, n)
	for i := range b {
		b[i] = letterBytes[rand.Int63()%int64(len(letterBytes))]
	}
	return string(b)
}
func flush(w http.ResponseWriter) {
	if f, ok := w.(http.Flusher); ok {
		f.Flush()
	} else {
		log.Println("unable to flush response writer")
	}
}

func filePart1(key string) string {
	return fmt.Sprintf(`
# liveness check
curl -s %s:%d/check?key=%s;
echo "liveness check complete";
sleep 1;
	`, hostname, port, key)
}

func filePart2Safe() string {
	return `
echo "you are looking at safe code. You should just pipe this to bash."
	`
}

func filePart2UnSafe() string {
	return `
echo "you have been pwnd. Never pipe curl to bash!"
	`
}
